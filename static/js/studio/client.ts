/**
 * Generated by orval v8.4.1 ðŸº
 * Do not edit manually.
 * OpenVox API
 * OpenAPI spec version: 1.0.0
 */
import axios from 'axios';
import type {
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

export interface SpeechGenerationBody {
  /** Text to synthesize */
  input: string;
  /** Voice ID or path */
  voice?: string;
  /** Model name (ignored, for OpenAI compatibility) */
  model?: string;
  /** Audio format: mp3, wav, pcm, opus */
  response_format?: string;
  /** Enable streaming response */
  stream?: boolean;
}

export interface CleaningSettings {
  /** How to handle code blocks: skip, read, summarize */
  code_block_rule?: string;
  remove_non_text?: boolean;
  handle_tables?: boolean;
  speak_urls?: boolean;
  expand_abbreviations?: boolean;
  preserve_parentheses?: boolean;
  preserve_structure?: boolean;
  paragraph_spacing?: number;
  section_spacing?: number;
  list_item_spacing?: number;
}

export interface UrlSettings {
  /** Use Jina Reader for URL extraction */
  use_jina?: boolean;
  /** Fall back to Jina if other methods fail */
  jina_fallback?: boolean;
}

export interface CreateSourceJsonBody {
  /** Raw text to import */
  text?: string;
  /** Source title */
  title?: string;
  /** URL to import content from */
  url?: string;
  /** Git repository URL to import */
  git_url?: string;
  /** Subdirectory path within the git repo */
  git_subpath?: string;
  /** Override cleaning options */
  cleaning_settings?: CleaningSettings;
  /** URL extraction settings */
  url_settings?: UrlSettings;
}

export interface CreateSourceFileBody {
  /** File to upload (.md, .txt) */
  file?: string;
}

export interface SourceCoverUploadBody {
  /** Cover art image file */
  cover?: string;
}

export interface UpdateSourceBody {
  title?: string;
  cleaned_text?: string;
}

export interface ReCleanSourceBody {
  code_block_rule?: string;
  remove_non_text?: boolean;
  handle_tables?: boolean;
  speak_urls?: boolean;
  expand_abbreviations?: boolean;
  preserve_parentheses?: boolean;
}

export interface MoveToFolderBody {
  /**
   * Target folder ID, or null for root
   * @nullable
   */
  folder_id?: string | null;
}

export interface CreateEpisodeBody {
  source_id: string;
  voice_id?: string;
  output_format?: string;
  /** paragraph, sentence, heading, or fixed */
  chunk_strategy?: string;
  chunk_max_length?: number;
  code_block_rule?: string;
  /** none, light, normal, heavy */
  breathing_intensity?: string;
  title?: string;
}

export interface UpdateEpisodeBody {
  title?: string;
}

export interface RegenerateWithSettingsBody {
  voice_id?: string;
  output_format?: string;
  chunk_strategy?: string;
  chunk_max_length?: number;
  code_block_rule?: string;
  breathing_intensity?: string;
}

export interface BulkMoveEpisodesBody {
  episode_ids: string[];
  /** @nullable */
  folder_id?: string | null;
}

export interface BulkDeleteEpisodesBody {
  episode_ids: string[];
}

export interface CreateFolderBody {
  name?: string;
  /** @nullable */
  parent_id?: string | null;
  sort_order?: number;
}

export interface UpdateFolderBody {
  name?: string;
  /** @nullable */
  parent_id?: string | null;
  sort_order?: number;
}

export interface ReorderItem {
  type?: string;
  id: string;
  sort_order: number;
}

export interface ReorderBody {
  items?: ReorderItem[];
}

export interface CreateTagBody {
  name: string;
}

export interface SetTagsBody {
  /** Tag IDs to assign (replaces existing) */
  tag_ids?: string[];
}

export interface SavePlaybackBody {
  current_chunk_index?: number;
  position_secs?: number;
  percent_listened?: number;
}

export interface UpdateSettingsBody { [key: string]: unknown }

export interface PreviewCleanBody {
  text: string;
  code_block_rule?: string;
}

export interface PreviewContentBody {
  /** Content type: url or git */
  type: string;
  url?: string;
  subpath?: string;
}

export interface PreviewChunksBody {
  text: string;
  strategy?: string;
  max_chars?: number;
}

export const getOpenVoxAPI = (axiosInstance: AxiosInstance = axios) => {
/**
 * Serve OpenAPI spec for Orval client generation.
 * @summary Serve OpenAPI spec for Orval client generation.
 */
const getOpenapiJson = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/openapi.json`,options
    );
  }

/**
 * Serve the web interface.
 * @summary Serve the web interface.
 */
const get = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/`,options
    );
  }

/**
 * Health check endpoint for container orchestration.

Returns service status and basic model info.
 * @summary Health check endpoint for container orchestration.
 */
const getHealth = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/health`,options
    );
  }

/**
 * List available voices.

Returns OpenAI-compatible voice list format.
 * @summary List available voices.
 */
const getV1Voices = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/v1/voices`,options
    );
  }

/**
 * OpenAI-compatible speech generation endpoint.

Request body:
    model: string (ignored, for compatibility)
    input: string (required) - Text to synthesize
    voice: string (optional) - Voice ID or path
    response_format: string (optional) - Audio format
    stream: boolean (optional) - Enable streaming

Returns:
    Audio file or streaming audio response
 * @summary OpenAI-compatible speech generation endpoint.
 */
const postV1AudioSpeech = (
    speechGenerationBody: SpeechGenerationBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/v1/audio/speech`,
      speechGenerationBody,options
    );
  }

/**
 * Upload file, submit URL, paste text, or import git repository.
 * @summary Upload file, submit URL, paste text, or import git
 */
const postApiStudioSources = (
    postApiStudioSourcesBody: CreateSourceJsonBody | CreateSourceFileBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/sources`,
      postApiStudioSourcesBody,options
    );
  }

/**
 * List all sources.
 * @summary List all sources.
 */
const getApiStudioSources = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/api/studio/sources`,options
    );
  }

/**
 * Get a source with cleaned text.
 * @summary Get a source with cleaned text.
 */
const getApiStudioSourcesSourceId = (
    sourceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/api/studio/sources/${sourceId}`,options
    );
  }

/**
 * Update source title or cleaned_text.
 * @summary Update source title or cleaned_text.
 */
const putApiStudioSourcesSourceId = (
    sourceId: string,
    updateSourceBody: UpdateSourceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.put(
      `/api/studio/sources/${sourceId}`,
      updateSourceBody,options
    );
  }

/**
 * Delete source and associated episodes/audio.
 * @summary Delete source and associated episodes/audio.
 */
const deleteApiStudioSourcesSourceId = (
    sourceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.delete(
      `/api/studio/sources/${sourceId}`,options
    );
  }

/**
 * Get cover art for a source.
 * @summary Get cover art for a source.
 */
const getApiStudioSourcesSourceIdCover = (
    sourceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/api/studio/sources/${sourceId}/cover`,options
    );
  }

/**
 * Upload cover art for a source.
 * @summary Upload cover art for a source.
 */
const postApiStudioSourcesSourceIdCover = (
    sourceId: string,
    sourceCoverUploadBody: SourceCoverUploadBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {const formData = new FormData();
if(sourceCoverUploadBody.cover !== undefined) {
 formData.append(`cover`, sourceCoverUploadBody.cover);
 }

    return axiosInstance.post(
      `/api/studio/sources/${sourceId}/cover`,
      formData,options
    );
  }

/**
 * Re-run normalizer on a source with different options.
 * @summary Re-run normalizer on a source with different optio
 */
const postApiStudioSourcesSourceIdReClean = (
    sourceId: string,
    reCleanSourceBody: ReCleanSourceBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/sources/${sourceId}/re-clean`,
      reCleanSourceBody,options
    );
  }

/**
 * Move a source to a folder.
 * @summary Move a source to a folder.
 */
const putApiStudioSourcesSourceIdMove = (
    sourceId: string,
    moveToFolderBody: MoveToFolderBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.put(
      `/api/studio/sources/${sourceId}/move`,
      moveToFolderBody,options
    );
  }

/**
 * Create an episode â€” chunk text and enqueue generation.
 * @summary Create an episode â€” chunk text and enqueue generat
 */
const postApiStudioEpisodes = (
    createEpisodeBody: CreateEpisodeBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/episodes`,
      createEpisodeBody,options
    );
  }

/**
 * List all episodes.
 * @summary List all episodes.
 */
const getApiStudioEpisodes = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/api/studio/episodes`,options
    );
  }

/**
 * Get episode with its chunks.
 * @summary Get episode with its chunks.
 */
const getApiStudioEpisodesEpisodeId = (
    episodeId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/api/studio/episodes/${episodeId}`,options
    );
  }

/**
 * Update episode metadata.
 * @summary Update episode metadata.
 */
const putApiStudioEpisodesEpisodeId = (
    episodeId: string,
    updateEpisodeBody: UpdateEpisodeBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.put(
      `/api/studio/episodes/${episodeId}`,
      updateEpisodeBody,options
    );
  }

/**
 * Delete episode and audio files.
 * @summary Delete episode and audio files.
 */
const deleteApiStudioEpisodesEpisodeId = (
    episodeId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.delete(
      `/api/studio/episodes/${episodeId}`,options
    );
  }

/**
 * Re-generate all chunks for an episode.
 * @summary Re-generate all chunks for an episode.
 */
const postApiStudioEpisodesEpisodeIdRegenerate = (
    episodeId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/episodes/${episodeId}/regenerate`,undefined,options
    );
  }

/**
 * Re-generate episode with new settings, with undo support.
 * @summary Re-generate episode with new settings, with undo s
 */
const postApiStudioEpisodesEpisodeIdRegenerateWithSettings = (
    episodeId: string,
    regenerateWithSettingsBody: RegenerateWithSettingsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/episodes/${episodeId}/regenerate-with-settings`,
      regenerateWithSettingsBody,options
    );
  }

/**
 * Undo an episode regeneration within the grace period.
 * @summary Undo an episode regeneration within the grace peri
 */
const postApiStudioUndoUndoId = (
    undoId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/undo/${undoId}`,undefined,options
    );
  }

/**
 * Move multiple episodes to a folder.
 * @summary Move multiple episodes to a folder.
 */
const postApiStudioEpisodesBulkMove = (
    bulkMoveEpisodesBody: BulkMoveEpisodesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/episodes/bulk-move`,
      bulkMoveEpisodesBody,options
    );
  }

/**
 * Delete multiple episodes.
 * @summary Delete multiple episodes.
 */
const postApiStudioEpisodesBulkDelete = (
    bulkDeleteEpisodesBody: BulkDeleteEpisodesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/episodes/bulk-delete`,
      bulkDeleteEpisodesBody,options
    );
  }

/**
 * Regenerate a single chunk.
 * @summary Regenerate a single chunk.
 */
const postApiStudioEpisodesEpisodeIdChunksChunkIndexRegenerate = (
    episodeId: string,
    chunkIndex: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/episodes/${episodeId}/chunks/${chunkIndex}/regenerate`,undefined,options
    );
  }

/**
 * Cancel a generating episode and reset error chunks to pending.
 * @summary Cancel a generating episode and reset error chunks
 */
const postApiStudioEpisodesEpisodeIdCancel = (
    episodeId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/episodes/${episodeId}/cancel`,undefined,options
    );
  }

/**
 * Retry all error chunks for an episode.
 * @summary Retry all error chunks for an episode.
 */
const postApiStudioEpisodesEpisodeIdRetryErrors = (
    episodeId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/episodes/${episodeId}/retry-errors`,undefined,options
    );
  }

/**
 * Serve a chunk's audio file.
 * @summary Serve a chunk's audio file.
 */
const getApiStudioEpisodesEpisodeIdAudioChunkIndex = (
    episodeId: string,
    chunkIndex: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/api/studio/episodes/${episodeId}/audio/${chunkIndex}`,options
    );
  }

/**
 * Serve merged full episode audio.
 * @summary Serve merged full episode audio.
 */
const getApiStudioEpisodesEpisodeIdAudioFull = (
    episodeId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/api/studio/episodes/${episodeId}/audio/full`,options
    );
  }

/**
 * Move an episode to a folder.
 * @summary Move an episode to a folder.
 */
const putApiStudioEpisodesEpisodeIdMove = (
    episodeId: string,
    moveToFolderBody: MoveToFolderBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.put(
      `/api/studio/episodes/${episodeId}/move`,
      moveToFolderBody,options
    );
  }

/**
 * Create a new folder.
 * @summary Create a new folder.
 */
const postApiStudioFolders = (
    createFolderBody: CreateFolderBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/folders`,
      createFolderBody,options
    );
  }

/**
 * Rename or move a folder.
 * @summary Rename or move a folder.
 */
const putApiStudioFoldersFolderId = (
    folderId: string,
    updateFolderBody: UpdateFolderBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.put(
      `/api/studio/folders/${folderId}`,
      updateFolderBody,options
    );
  }

/**
 * Delete a folder and all its contents (episodes audio files are deleted).
 * @summary Delete a folder and all its contents (episodes aud
 */
const deleteApiStudioFoldersFolderId = (
    folderId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.delete(
      `/api/studio/folders/${folderId}`,options
    );
  }

/**
 * Start playing all episodes in a folder as a playlist.
 * @summary Start playing all episodes in a folder as a playli
 */
const postApiStudioFoldersFolderIdPlaylist = (
    folderId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/folders/${folderId}/playlist`,undefined,options
    );
  }

/**
 * Get all episodes in a folder for playlist building.
 * @summary Get all episodes in a folder for playlist building
 */
const getApiStudioFoldersFolderIdEpisodes = (
    folderId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/api/studio/folders/${folderId}/episodes`,options
    );
  }

/**
 * Batch update sort orders.
 * @summary Batch update sort orders.
 */
const postApiStudioReorder = (
    reorderBody: ReorderBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/reorder`,
      reorderBody,options
    );
  }

/**
 * List all tags.
 * @summary List all tags.
 */
const getApiStudioTags = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/api/studio/tags`,options
    );
  }

/**
 * Create a tag.
 * @summary Create a tag.
 */
const postApiStudioTags = (
    createTagBody: CreateTagBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/tags`,
      createTagBody,options
    );
  }

/**
 * Delete a tag.
 * @summary Delete a tag.
 */
const deleteApiStudioTagsTagId = (
    tagId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.delete(
      `/api/studio/tags/${tagId}`,options
    );
  }

/**
 * Set tags for a source (replaces all existing).
 * @summary Set tags for a source (replaces all existing).
 */
const postApiStudioSourcesSourceIdTags = (
    sourceId: string,
    setTagsBody: SetTagsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/sources/${sourceId}/tags`,
      setTagsBody,options
    );
  }

/**
 * Set tags for an episode (replaces all existing).
 * @summary Set tags for an episode (replaces all existing).
 */
const postApiStudioEpisodesEpisodeIdTags = (
    episodeId: string,
    setTagsBody: SetTagsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/episodes/${episodeId}/tags`,
      setTagsBody,options
    );
  }

/**
 * Get playback state for an episode.
 * @summary Get playback state for an episode.
 */
const getApiStudioPlaybackEpisodeId = (
    episodeId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/api/studio/playback/${episodeId}`,options
    );
  }

/**
 * Save playback position.
 * @summary Save playback position.
 */
const postApiStudioPlaybackEpisodeId = (
    episodeId: string,
    savePlaybackBody: SavePlaybackBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/playback/${episodeId}`,
      savePlaybackBody,options
    );
  }

/**
 * Get all settings.
 * @summary Get all settings.
 */
const getApiStudioSettings = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/api/studio/settings`,options
    );
  }

/**
 * Update settings (key-value pairs).
 * @summary Update settings (key-value pairs).
 */
const putApiStudioSettings = (
    updateSettingsBody: UpdateSettingsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.put(
      `/api/studio/settings`,
      updateSettingsBody,options
    );
  }

/**
 * Get generation queue status.
 * @summary Get generation queue status.
 */
const getApiStudioGenerationStatus = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/api/studio/generation/status`,options
    );
  }

/**
 * Get the full library tree structure.
 * @summary Get the full library tree structure.
 */
const getApiStudioLibraryTree = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.get(
      `/api/studio/library/tree`,options
    );
  }

/**
 * Preview normalization without saving.
 * @summary Preview normalization without saving.
 */
const postApiStudioPreviewClean = (
    previewCleanBody: PreviewCleanBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/preview-clean`,
      previewCleanBody,options
    );
  }

/**
 * Preview content without importing - for URL and git repos.
 * @summary Preview content without importing - for URL and gi
 */
const postApiStudioPreviewContent = (
    previewContentBody: PreviewContentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/preview-content`,
      previewContentBody,options
    );
  }

/**
 * Preview chunking without creating an episode.
 * @summary Preview chunking without creating an episode.
 */
const postApiStudioPreviewChunks = (
    previewChunksBody: PreviewChunksBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axiosInstance.post(
      `/api/studio/preview-chunks`,
      previewChunksBody,options
    );
  }

return {getOpenapiJson,get,getHealth,getV1Voices,postV1AudioSpeech,postApiStudioSources,getApiStudioSources,getApiStudioSourcesSourceId,putApiStudioSourcesSourceId,deleteApiStudioSourcesSourceId,getApiStudioSourcesSourceIdCover,postApiStudioSourcesSourceIdCover,postApiStudioSourcesSourceIdReClean,putApiStudioSourcesSourceIdMove,postApiStudioEpisodes,getApiStudioEpisodes,getApiStudioEpisodesEpisodeId,putApiStudioEpisodesEpisodeId,deleteApiStudioEpisodesEpisodeId,postApiStudioEpisodesEpisodeIdRegenerate,postApiStudioEpisodesEpisodeIdRegenerateWithSettings,postApiStudioUndoUndoId,postApiStudioEpisodesBulkMove,postApiStudioEpisodesBulkDelete,postApiStudioEpisodesEpisodeIdChunksChunkIndexRegenerate,postApiStudioEpisodesEpisodeIdCancel,postApiStudioEpisodesEpisodeIdRetryErrors,getApiStudioEpisodesEpisodeIdAudioChunkIndex,getApiStudioEpisodesEpisodeIdAudioFull,putApiStudioEpisodesEpisodeIdMove,postApiStudioFolders,putApiStudioFoldersFolderId,deleteApiStudioFoldersFolderId,postApiStudioFoldersFolderIdPlaylist,getApiStudioFoldersFolderIdEpisodes,postApiStudioReorder,getApiStudioTags,postApiStudioTags,deleteApiStudioTagsTagId,postApiStudioSourcesSourceIdTags,postApiStudioEpisodesEpisodeIdTags,getApiStudioPlaybackEpisodeId,postApiStudioPlaybackEpisodeId,getApiStudioSettings,putApiStudioSettings,getApiStudioGenerationStatus,getApiStudioLibraryTree,postApiStudioPreviewClean,postApiStudioPreviewContent,postApiStudioPreviewChunks}};
export type GetOpenapiJsonResult = AxiosResponse<void>
export type GetResult = AxiosResponse<void>
export type GetHealthResult = AxiosResponse<void>
export type GetV1VoicesResult = AxiosResponse<void>
export type PostV1AudioSpeechResult = AxiosResponse<void>
export type PostApiStudioSourcesResult = AxiosResponse<void>
export type GetApiStudioSourcesResult = AxiosResponse<void>
export type GetApiStudioSourcesSourceIdResult = AxiosResponse<void>
export type PutApiStudioSourcesSourceIdResult = AxiosResponse<void>
export type DeleteApiStudioSourcesSourceIdResult = AxiosResponse<void>
export type GetApiStudioSourcesSourceIdCoverResult = AxiosResponse<void>
export type PostApiStudioSourcesSourceIdCoverResult = AxiosResponse<void>
export type PostApiStudioSourcesSourceIdReCleanResult = AxiosResponse<void>
export type PutApiStudioSourcesSourceIdMoveResult = AxiosResponse<void>
export type PostApiStudioEpisodesResult = AxiosResponse<void>
export type GetApiStudioEpisodesResult = AxiosResponse<void>
export type GetApiStudioEpisodesEpisodeIdResult = AxiosResponse<void>
export type PutApiStudioEpisodesEpisodeIdResult = AxiosResponse<void>
export type DeleteApiStudioEpisodesEpisodeIdResult = AxiosResponse<void>
export type PostApiStudioEpisodesEpisodeIdRegenerateResult = AxiosResponse<void>
export type PostApiStudioEpisodesEpisodeIdRegenerateWithSettingsResult = AxiosResponse<void>
export type PostApiStudioUndoUndoIdResult = AxiosResponse<void>
export type PostApiStudioEpisodesBulkMoveResult = AxiosResponse<void>
export type PostApiStudioEpisodesBulkDeleteResult = AxiosResponse<void>
export type PostApiStudioEpisodesEpisodeIdChunksChunkIndexRegenerateResult = AxiosResponse<void>
export type PostApiStudioEpisodesEpisodeIdCancelResult = AxiosResponse<void>
export type PostApiStudioEpisodesEpisodeIdRetryErrorsResult = AxiosResponse<void>
export type GetApiStudioEpisodesEpisodeIdAudioChunkIndexResult = AxiosResponse<void>
export type GetApiStudioEpisodesEpisodeIdAudioFullResult = AxiosResponse<void>
export type PutApiStudioEpisodesEpisodeIdMoveResult = AxiosResponse<void>
export type PostApiStudioFoldersResult = AxiosResponse<void>
export type PutApiStudioFoldersFolderIdResult = AxiosResponse<void>
export type DeleteApiStudioFoldersFolderIdResult = AxiosResponse<void>
export type PostApiStudioFoldersFolderIdPlaylistResult = AxiosResponse<void>
export type GetApiStudioFoldersFolderIdEpisodesResult = AxiosResponse<void>
export type PostApiStudioReorderResult = AxiosResponse<void>
export type GetApiStudioTagsResult = AxiosResponse<void>
export type PostApiStudioTagsResult = AxiosResponse<void>
export type DeleteApiStudioTagsTagIdResult = AxiosResponse<void>
export type PostApiStudioSourcesSourceIdTagsResult = AxiosResponse<void>
export type PostApiStudioEpisodesEpisodeIdTagsResult = AxiosResponse<void>
export type GetApiStudioPlaybackEpisodeIdResult = AxiosResponse<void>
export type PostApiStudioPlaybackEpisodeIdResult = AxiosResponse<void>
export type GetApiStudioSettingsResult = AxiosResponse<void>
export type PutApiStudioSettingsResult = AxiosResponse<void>
export type GetApiStudioGenerationStatusResult = AxiosResponse<void>
export type GetApiStudioLibraryTreeResult = AxiosResponse<void>
export type PostApiStudioPreviewCleanResult = AxiosResponse<void>
export type PostApiStudioPreviewContentResult = AxiosResponse<void>
export type PostApiStudioPreviewChunksResult = AxiosResponse<void>
